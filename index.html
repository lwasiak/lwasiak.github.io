<html>

<head>
<title>Benchmark</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<style>
body {
  margin: 0px;
}
</style>

<script type="text/javascript" src="assets/gl-matrix-min.js"></script>

<script type="text/javascript" src="vertexArrays.js"></script>
<script type="text/javascript" src="utils.js"></script>
<script type="text/javascript" src="init.js"></script>
<script type="text/javascript" src="input.js"></script>
<script type="text/javascript" src="draw.js"></script>

<script id="vertGrass" type="x-shader/x-vertex">
/**
    Vertex shader used to draw grass objects if vertex texture sampling is available.
*/

    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;             /**< Model view matrix */
    uniform mat4 uCamMatrix;            /**< Eye camera position matrix */
    uniform mat4 uPMatrix;              /**< Perspective matrix */
    uniform mat3 uNMatrix;              /**< Normal matrix */
    uniform mat4 uShadowCamMatrix;      /**< Shadow camera position matrix */

    uniform bool uUseWind;              /**< Move grass objects to simulate the wind */
    uniform float uTime;                /**< Time passed */
    uniform float uBendFactor;          /**< Max bend of grass caused by wind */
    uniform sampler2D uWindXSampler;    /**< Texture to define bend in X direction caused by wind */
    uniform sampler2D uWindZSampler;    /**< Texture to define bend in Z direction caused by wind */

    varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;    /**< Normal vector in space */
    varying vec4 vLightPosition;        /**< Position of point light from current vertex */
    varying vec2 vShadowCoord;          /**< Coordinates used to sample shadow map */
    varying float vShadowDistance;      /**< Distance from shadow camera to current object */

    const vec2 v2 = vec2(0.5, 0.5);     /**< Vector used to count shadow texture coordinates */

    void main(void) {
        if (uUseWind && aTextureCoord.y > 0.1) {
            /**
                Count position of upper vertices after applying wind effect
            */
            float xBend = (texture2D(uWindXSampler, vec2((aVertexPosition.x + 0.5) / 128.0 + uTime, 1.0 - (-(aVertexPosition.z - 0.5) / 128.0))).r) - 0.5;
            xBend *= uBendFactor;
            float zBend = (texture2D(uWindZSampler, vec2((aVertexPosition.x + 0.5) / 128.0, 1.0 - (-(aVertexPosition.z - 0.5) / 128.0) - uTime)).r) - 0.5;
            zBend *= uBendFactor;

            vLightPosition = uMVMatrix * vec4(aVertexPosition.x - xBend, aVertexPosition.y, aVertexPosition.z - zBend, 1.0);
        } else {
            vLightPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        }

        gl_Position = uPMatrix * uCamMatrix * vLightPosition;

        /**
            Count distance from shadow camera to vertex and coordinate to sample shadow map.
            If vertex is not visible on shadow map set max distance.
        */
        vec4 shadowPosition = uPMatrix * uShadowCamMatrix * vLightPosition;
        vec4 shadowCoordinateWdivide = shadowPosition / shadowPosition.w;
        vShadowCoord = shadowCoordinateWdivide.xy * v2 + v2;
        if (vShadowCoord.x < 0.0 || vShadowCoord.x > 1.0 || vShadowCoord.y < 0.0 || vShadowCoord.y > 1.0) {
            vShadowDistance = 100.0;
        } else {
            vShadowDistance = shadowPosition.z * 0.005;
        }

        /**
            Flip the texture in Y axis
        */
        vTextureCoord = 1.0 - aTextureCoord;

        vTransformedNormal = uNMatrix * aVertexNormal;
    }
</script>

<script id="vertGrassNoSampler" type="x-shader/x-vertex">
/**
    Vertex shader used to draw grass objects if vertex texture sampling is NOT available.
*/

    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;             /**< Model view matrix */
    uniform mat4 uCamMatrix;            /**< Eye camera position matrix */
    uniform mat4 uPMatrix;              /**< Perspective matrix */
    uniform mat3 uNMatrix;              /**< Normal matrix */
    uniform mat4 uShadowCamMatrix;      /**< Shadow camera position matrix */

    varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;    /**< Normal vector in space */
    varying vec4 vLightPosition;        /**< Position of point light from current vertex */
    varying vec2 vShadowCoord;          /**< Coordinates used to sample shadow map */
    varying float vShadowDistance;      /**< Distance from shadow camera to current object */

    const vec2 v2 = vec2(0.5, 0.5);     /**< Vector used to count shadow texture coordinates */

    void main(void) {
        vLightPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * uCamMatrix * vLightPosition;

        /**
            Count distance from shadow camera to vertex and coordinate to sample shadow map.
            If vertex is not visible on shadow map set max distance.
        */
        vec4 shadowPosition = uPMatrix * uShadowCamMatrix * vLightPosition;
        vec4 shadowCoordinateWdivide = shadowPosition / shadowPosition.w;
        vShadowCoord = shadowCoordinateWdivide.xy * v2 + v2;
        if (vShadowCoord.x < 0.0 || vShadowCoord.x > 1.0 || vShadowCoord.y < 0.0 || vShadowCoord.y > 1.0) {
            vShadowDistance = 100.0;
        } else {
            vShadowDistance = shadowPosition.z * 0.005;
        }

        /**
            Flip the texture in Y axis
        */
        vTextureCoord = 1.0 - aTextureCoord;

        vTransformedNormal = uNMatrix * aVertexNormal;
    }
</script>

<script id="fragGrass" type="x-shader/x-fragment">
/**
    Fragment shader used to draw grass objects
*/

    precision mediump float;

    uniform sampler2D uSampler;             /**< Texture to apply on the object */
    uniform sampler2D uShadowSampler;       /**< Shadow map sampler */
    uniform float uRainDensity;             /**< Intensivity of rain */
    uniform bool uUseShadows;               /**< Apply shadows to the object */
    uniform bool uUseSoftShadows;           /**< Apply PCF shadows to the object */
    uniform vec2 uShadowMapResolution;      /**< Size of shadow map */
    uniform bool uUseLighting;              /**< Apply lighting to the object */
    uniform vec3 uAmbientColor;             /**< RGB color of ambient light */
    uniform vec3 uPointLightLocation;       /**< Position of point light in space */
    uniform vec3 uPointLightColor;          /**< RGB color of point light */

    varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;        /**< Normal vector in space */
    varying vec4 vLightPosition;            /**< Position of point light from current vertex */
    varying vec2 vShadowCoord;              /**< Coordinates used to sample shadow map */
    varying float vShadowDistance;          /**< Distance from shadow camera to current object */

    const vec3 grey = vec3(0.2, 0.2, 0.2);  /**< Gray color in RGB used when it's raining */

    void main(void) {
        /**
            Sample the texture.
            If current pixel is transparent don't draw it.
        */
        vec4 textureColor = texture2D(uSampler, vTextureCoord);
        if (textureColor.a < 0.75) {
            discard;
        }

        /**
            Count color added by lights
        */
        vec3 lightWeighting;
        if (!uUseLighting) {
            lightWeighting = vec3(1.0, 1.0, 1.0);
        } else {
            vec3 lightDirection = normalize(uPointLightLocation - vLightPosition.xyz);
            float directionalLightWeighting = max(dot(normalize(vTransformedNormal), lightDirection), 0.0);
            lightWeighting = uAmbientColor + uPointLightColor * directionalLightWeighting;
        }

        /**
            Sample the shadow map and check if there is any occluder between current fragment and light
        */
        float visibility = 1.0;
        if (uUseShadows && vShadowDistance < 1.0) {
            const float bias = 0.003;

            if (uUseSoftShadows) {
                /**
                    Sample the current pixel and 8 pixels around it.
                    Check if current fragment is fully or only partialy hidden from light.
                    Creates penumbra zone on the edge of the shadow.
                */
                float sum = 0.0;
                for (float i = -1.0; i < 1.1; i++) {
                    for (float j = -1.0; j < 1.1; j++) {
                        float distanceFromLight = texture2D(uShadowSampler, vec2(vShadowCoord.x + (j * uShadowMapResolution.x), vShadowCoord.y + (i * uShadowMapResolution.y))).z;
                        if (vShadowDistance > distanceFromLight + bias) {
                            sum += 1.0;
                        }
                    }
                }
                visibility = 1.0 - 0.5 * (sum / 9.0);
            } else {
                /**
                    Sample only one pixel and check if fragment is hidden.
                */
                float distanceFromLight = texture2D(uShadowSampler, vShadowCoord).z;
                if (vShadowDistance > distanceFromLight + bias) {
                    visibility = 0.5;
                }
            }
        }

        gl_FragColor = vec4(textureColor.rgb * lightWeighting * visibility, textureColor.a);

        /**
            When it's raining mix the counted color with gray
        */
        if (uRainDensity > 0.05) {
            vec3 grayed = mix(gl_FragColor.rgb, grey, uRainDensity * 0.5);
            gl_FragColor = vec4(grayed, textureColor.a);
        }
    }
</script>

<!-- ____________________________________________________________ -->

<script id="vertGround" type="x-shader/x-vertex">
/**
    Vertex shader used to draw ground
*/

    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;             /**< Model view matrix */
    uniform mat4 uCamMatrix;            /**< Eye camera position matrix */
    uniform mat4 uPMatrix;              /**< Perspective matrix */
    uniform mat4 uShadowCamMatrix;      /**< Shadow camera position matrix */

    varying vec2 vTextureCoord;
    varying vec4 vLightPosition;        /**< Position of point light from current vertex */
    varying vec2 vShadowCoord;          /**< Coordinates used to sample shadow map */
    varying float vShadowDistance;      /**< Distance from shadow camera to current object */

    const vec2 v2 = vec2(0.5, 0.5);     /**< Vector used to count shadow texture coordinates */

    void main(void) {
        vLightPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * uCamMatrix * vLightPosition;

        /**
            Count distance from shadow camera to vertex and coordinate to sample shadow map.
            If vertex is not visible on shadow map set max distance.
        */
        vec4 shadowPosition = uPMatrix * uShadowCamMatrix * vLightPosition;
        vec4 shadowCoordinateWdivide = shadowPosition / shadowPosition.w;
        vShadowCoord = shadowCoordinateWdivide.xy * v2 + v2;
        if (vShadowCoord.x < 0.0 || vShadowCoord.x > 1.0 || vShadowCoord.y < 0.0 || vShadowCoord.y > 1.0) {
            vShadowDistance = 100.0;
        } else {
            vShadowDistance = shadowPosition.z * 0.005;
        }

        /**
            Flip the texture in Y axis
        */
        vTextureCoord = 10.0 - aTextureCoord;
    }
</script>

<script id="fragGround" type="x-shader/x-fragment">
/**
    Fragment shader used to draw ground
*/
    precision mediump float;

    uniform sampler2D uGroundASampler;      /**< 1st texture to apply on the object */
    uniform sampler2D uGroundBSampler;      /**< 2nd texture to apply on the object */
    uniform sampler2D uShadowSampler;       /**< Shadow map sampler */
    uniform sampler2D uNormalMapSampler;    /**< Normal map sampler */
    uniform float uRainDensity;             /**< Intensivity of rain */
    uniform bool uUseShadows;               /**< Apply shadows to the object */
    uniform bool uUseSoftShadows;           /**< Apply PCF shadows to the object */
    uniform vec2 uShadowMapResolution;      /**< Size of shadow map */
    uniform bool uUseLighting;              /**< Apply lighting to the object */
    uniform vec3 uAmbientColor;             /**< RGB color of ambient light */
    uniform vec3 uPointLightLocation;       /**< Position of point light in space */
    uniform vec3 uPointLightColor;          /**< RGB color of point light */

    varying vec2 vTextureCoord;
    varying vec4 vLightPosition;            /**< Position of point light from current vertex */
    varying vec2 vShadowCoord;              /**< Coordinates used to sample shadow map */
    varying float vShadowDistance;          /**< Distance from shadow camera to current object */

    const vec3 grey = vec3(0.2, 0.2, 0.2);  /**< Gray color in RGB used when it's raining */

    void main(void) {
        /**
            Count color added by lights
        */
        vec3 lightWeighting;
        if (!uUseLighting) {
            lightWeighting = vec3(1.0, 1.0, 1.0);
        } else {
            vec3 normalMap = texture2D(uNormalMapSampler, vec2(vTextureCoord / 10.0) ).rgb;
            vec3 lightDirection = normalize(uPointLightLocation - vLightPosition.xyz);
            vec3 normal = normalize(normalMap * 2.0 - 1.0);

            vec3 diffuse = uPointLightColor.rgb * max(dot(normal, lightDirection), 0.0);
            lightWeighting = uAmbientColor + uPointLightColor * diffuse;
        }

        /**
            Sample the shadow map and check if there is any occluder between current fragment and light
        */
        float visibility = 1.0;
        if (uUseShadows && vShadowDistance < 1.0) {
            const float bias = 0.003;

            if (uUseSoftShadows) {
                /**
                    Sample the current pixel and 8 pixels around it.
                    Check if current fragment is fully or only partialy hidden from light.
                    Creates penumbra zone on the edge of the shadow.
                */
                float sum = 0.0;
                for (float i = -1.0; i < 1.1; i++) {
                    for (float j = -1.0; j < 1.1; j++) {
                        float distanceFromLight = texture2D(uShadowSampler, vec2(vShadowCoord.x + (j * uShadowMapResolution.x), vShadowCoord.y + (i * uShadowMapResolution.y))).z;
                        if (vShadowDistance > distanceFromLight + bias) {
                            sum += 1.0;
                        }
                    }
                }
                visibility = 1.0 - 0.5 * (sum / 9.0);
            } else {
                /**
                    Sample only one pixel and check if fragment is hidden.
                */
                float distanceFromLight = texture2D(uShadowSampler, vShadowCoord).z;
                if (vShadowDistance > distanceFromLight + bias) {
                    visibility = 0.5;
                }
            }
        }

        /**
            Sample and mix two textures applied to the ground
        */
        vec4 colorA = texture2D(uGroundASampler, vTextureCoord);
        vec2 coord = vTextureCoord / 2.2;
        vec4 colorB = texture2D(uGroundBSampler, coord);
        vec4 textureColor = colorA * 0.6 + colorB * 0.4;

        gl_FragColor = vec4(textureColor.rgb * lightWeighting * visibility, textureColor.a);

        /**
            When it's raining mix the counted color with gray
        */
        if (uRainDensity > 0.05) {
            vec3 grayed = mix(gl_FragColor.rgb, grey, uRainDensity * 0.5);
            gl_FragColor = vec4(grayed, textureColor.a);
        }
    }
</script>

<!-- ____________________________________________________________ -->

<script id="vertTree" type="x-shader/x-vertex">
/**
    Vertex shader used to draw tress if vertex texture sampling is available.
*/

    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;             /**< Model view matrix */
    uniform mat4 uCamMatrix;            /**< Eye camera position matrix */
    uniform mat4 uPMatrix;              /**< Perspective matrix */
    uniform mat3 uNMatrix;              /**< Normal matrix */
    uniform mat4 uShadowCamMatrix;      /**< Shadow camera position matrix */

    uniform bool uUseWind;              /**< Move grass objects to simulate the wind */
    uniform float uTime;                /**< Time passed */
    uniform float uBendFactor;          /**< Max bend of grass caused by wind */
    uniform vec2 uTreeCenter;           /**< Position of the center of the tree */
    uniform sampler2D uWindXSampler;    /**< Texture to define bend in X direction caused by wind */
    uniform sampler2D uWindZSampler;    /**< Texture to define bend in Z direction caused by wind */

    varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;    /**< Normal vector in space */
    varying vec4 vLightPosition;        /**< Position of point light from current vertex */
    varying vec2 vShadowCoord;          /**< Coordinates used to sample shadow map */
    varying float vShadowDistance;      /**< Distance from shadow camera to current object */

    const vec2 v2 = vec2(0.5, 0.5);     /**< Vector used to count shadow texture coordinates */

    void main(void) {
        if (uUseWind && aTextureCoord.y > 0.75) {
            /**
                Count position of upper vertices after applying wind effect
            */
            float xBend = (texture2D(uWindXSampler, vec2((uTreeCenter.x + 0.5) / 128.0 + uTime, (uTreeCenter.y - 0.5) / 128.0)).r) - 0.5;
            xBend *= uBendFactor;
            float zBend = (texture2D(uWindZSampler, vec2((uTreeCenter.x + 0.5) / 128.0, (uTreeCenter.y - 0.5) / 128.0 - uTime)).r) - 0.5;
            zBend *= uBendFactor;

            vLightPosition = uMVMatrix * vec4(aVertexPosition.x - xBend, aVertexPosition.y, aVertexPosition.z - zBend, 1.0);
        } else {
            vLightPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        }

        gl_Position = uPMatrix * uCamMatrix * vLightPosition;

        /**
            Count distance from shadow camera to vertex and coordinate to sample shadow map.
            If vertex is not visible on shadow map set max distance.
        */
        vec4 shadowPosition = uPMatrix * uShadowCamMatrix * vLightPosition;
        vec4 shadowCoordinateWdivide = shadowPosition / shadowPosition.w;
        vShadowCoord = shadowCoordinateWdivide.xy * v2 + v2;
        if (vShadowCoord.x < 0.0 || vShadowCoord.x > 1.0 || vShadowCoord.y < 0.0 || vShadowCoord.y > 1.0) {
            vShadowDistance = 100.0;
        } else {
            vShadowDistance = shadowPosition.z * 0.005;
        }

        /**
            Flip the texture in Y axis
        */
        vTextureCoord = 1.0 - aTextureCoord;

        vTransformedNormal = uNMatrix * aVertexNormal;
    }
</script>

<script id="vertTreeNoSampler" type="x-shader/x-vertex">
/**
    Vertex shader used to draw trees if vertex texture sampling is NOT available.
*/

    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;             /**< Model view matrix */
    uniform mat4 uCamMatrix;            /**< Eye camera position matrix */
    uniform mat4 uPMatrix;              /**< Perspective matrix */
    uniform mat3 uNMatrix;              /**< Normal matrix */
    uniform mat4 uShadowCamMatrix;      /**< Shadow camera position matrix */

    varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;    /**< Normal vector in space */
    varying vec4 vLightPosition;        /**< Position of point light from current vertex */
    varying vec2 vShadowCoord;          /**< Coordinates used to sample shadow map */
    varying float vShadowDistance;      /**< Distance from shadow camera to current object */

    const vec2 v2 = vec2(0.5, 0.5);     /**< Vector used to count shadow texture coordinates */

    void main(void) {
        vLightPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * uCamMatrix * vLightPosition;

        /**
            Count distance from shadow camera to vertex and coordinate to sample shadow map.
            If vertex is not visible on shadow map set max distance.
        */
        vec4 shadowPosition = uPMatrix * uShadowCamMatrix * vLightPosition;
        vec4 shadowCoordinateWdivide = shadowPosition / shadowPosition.w;
        vShadowCoord = shadowCoordinateWdivide.xy * v2 + v2;
        if (vShadowCoord.x < 0.0 || vShadowCoord.x > 1.0 || vShadowCoord.y < 0.0 || vShadowCoord.y > 1.0) {
            vShadowDistance = 100.0;
        } else {
            vShadowDistance = shadowPosition.z * 0.005;
        }

        /**
            Flip the texture in Y axis
        */
        vTextureCoord = 1.0 - aTextureCoord;

        vTransformedNormal = uNMatrix * aVertexNormal;
    }
</script>

<script id="fragTree" type="x-shader/x-fragment">
/**
    Fragment shader used to draw trees
*/

    precision mediump float;

    uniform sampler2D uSampler;             /**< Texture to apply on the object */
    uniform sampler2D uShadowSampler;       /**< Shadow map sampler */
    uniform float uRainDensity;             /**< Intensivity of rain */
    uniform bool uUseShadows;               /**< Apply shadows to the object */
    uniform bool uUseSoftShadows;           /**< Apply PCF shadows to the object */
    uniform vec2 uShadowMapResolution;      /**< Size of shadow map */
    uniform bool uUseLighting;              /**< Apply lighting to the object */
    uniform vec3 uAmbientColor;             /**< RGB color of ambient light */
    uniform vec3 uPointLightLocation;       /**< Position of point light in space */
    uniform vec3 uPointLightColor;          /**< RGB color of point light */

    varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;        /**< Normal vector in space */
    varying vec4 vLightPosition;            /**< Position of point light from current vertex */
    varying vec2 vShadowCoord;              /**< Coordinates used to sample shadow map */
    varying float vShadowDistance;          /**< Distance from shadow camera to current object */

    const vec3 grey = vec3(0.2, 0.2, 0.2);  /**< Gray color in RGB used when it's raining */

    void main(void) {
        /**
            Sample the texture.
            If current pixel is transparent don't draw it.
        */
        vec4 textureColor = texture2D(uSampler, vTextureCoord);
        if (textureColor.a < 0.75) {
            discard;
        }

        /**
            Count color added by lights
        */
        vec3 lightWeighting;
        if (!uUseLighting) {
            lightWeighting = vec3(1.0, 1.0, 1.0);
        } else {
            vec3 lightDirection = normalize(uPointLightLocation - vLightPosition.xyz);
            float directionalLightWeighting = max(dot(normalize(vTransformedNormal), lightDirection), 0.0);
            lightWeighting = uAmbientColor + uPointLightColor * directionalLightWeighting;
        }

        /**
            Sample the shadow map and check if there is any occluder between current fragment and light
        */
        float visibility = 1.0;
        if (uUseShadows && vShadowDistance < 1.0) {
            const float bias = 0.003;

            if (uUseSoftShadows) {
                /**
                    Sample the current pixel and 8 pixels around it.
                    Check if current fragment is fully or only partialy hidden from light.
                    Creates penumbra zone on the edge of the shadow.
                */
                float sum = 0.0;
                for (float i = -1.0; i < 1.1; i++) {
                    for (float j = -1.0; j < 1.1; j++) {
                        float distanceFromLight = texture2D(uShadowSampler, vec2(vShadowCoord.x + (j * uShadowMapResolution.x), vShadowCoord.y + (i * uShadowMapResolution.y))).z;
                        if (vShadowDistance > distanceFromLight + bias) {
                            sum += 1.0;
                        }
                    }
                }
                visibility = 1.0 - 0.5 * (sum / 9.0);
            } else {
                /**
                    Sample only one pixel and check if fragment is hidden.
                */
                float distanceFromLight = texture2D(uShadowSampler, vShadowCoord).z;
                if (vShadowDistance > distanceFromLight + bias) {
                    visibility = 0.5;
                }
            }
        }

        gl_FragColor = vec4(textureColor.rgb * lightWeighting * visibility, textureColor.a);

        /**
            When it's raining mix the counted color with gray
        */
        if (uRainDensity > 0.05) {
            vec3 grayed = mix(gl_FragColor.rgb, grey, uRainDensity * 0.5);
            gl_FragColor = vec4(grayed, textureColor.a);
        }
    }
</script>

<!-- ____________________________________________________________ -->

<script id="vertSkybox" type="x-shader/x-vertex">
/**
    Vertex shader used to draw skybox
*/
    attribute vec3 aVertexPosition;

    uniform mat4 uMVMatrix;                 /**< Model view matrix */
    uniform mat4 uCamMatrix;                /**< Eye camera position matrix */
    uniform mat4 uPMatrix;                  /**< Perspective matrix */

    varying vec3 vTextureCoord;

    const vec3 v3 = vec3(0.5, 0.5, 0.5);    /**< Vector used to count cube texture coordinates */

    void main(void) {
        gl_Position = uPMatrix * uCamMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

        vTextureCoord = aVertexPosition * v3 + v3;
    }
</script>

<script id="fragSkybox" type="x-shader/x-fragment">
/**
    Fragment shader used to draw skybox
*/

    precision mediump float;

    uniform samplerCube uSampler;               /**< Cube texture to apply on the sky */
    uniform float uRainDensity;                 /**< Intensivity of rain */

    varying vec3 vTextureCoord;

    const vec3 grey = vec3(0.5, 0.5, 0.5);      /**< Gray color in RGB used when it's raining */

    void main(void) {
        /**
            Sample the texture and mix with grey color when it's raining
        */
        vec4 texture = textureCube(uSampler, vTextureCoord);
        gl_FragColor = mix(texture, vec4(grey, 1.0), uRainDensity);
    }
</script>

<!-- ____________________________________________________________ -->

<script id="vertRain" type="x-shader/x-vertex">
/**
    Vertex shader used to draw rain
*/

    attribute vec3 aVertexPosition;
    attribute float aAlpha;

    uniform mat4 uMVMatrix;             /**< Model view matrix */
    uniform mat4 uCamMatrix;            /**< Eye camera position matrix */
    uniform mat4 uPMatrix;              /**< Perspective matrix */

    varying float vAlpha;

    void main(void) {
        gl_Position = uPMatrix * uCamMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vAlpha = aAlpha;
    }
</script>

<script id="fragRain" type="x-shader/x-fragment">
/**
    Fragment shader used to draw rain
*/
    precision mediump float;

    varying float vAlpha;

    void main(void) {
        gl_FragColor = vec4(0.2, 0.2, 0.2, vAlpha);
    }
</script>

<!-- ____________________________________________________________ -->

<script id="vertSphere" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;

    uniform mat4 uMVMatrix;                 /**< Model view matrix */
    uniform mat4 uCamMatrix;                /**< Eye camera position matrix */
    uniform mat4 uPMatrix;                  /**< Perspective matrix */
    uniform mat3 uNMatrix;                  /**< Normal matrix */

    uniform vec3 uCameraPosition;

    varying vec3 vTextureCoord;

    const vec3 v3 = vec3(0.5, 0.5, 0.5);
    
    void main(void) {
        vec4 position = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * uCamMatrix * position;

        /* Calculate incident ray for environment mapping. */
        vec3 incidentRay = normalize(position.xyz - uCameraPosition);
        vec3 vTransformedNormal = uNMatrix * aVertexNormal;

        /* Calculate reflected ray for environment mapping and pass it to fragment shader. */
        vTextureCoord = reflect(incidentRay, normalize(vTransformedNormal));
    }
</script>

<script id="fragSphere" type="x-shader/x-fragment">
    precision mediump float;

    uniform samplerCube uSampler;                       /**< Cube texture to apply on the sky */
    uniform float uRainDensity;                         /**< Intensivity of rain */

    varying vec3 vTextureCoord;

    const vec3 grey = vec3(0.5, 0.5, 0.5);              /**< Gray color in RGB used when it's raining */
    const vec3 sphereColor = vec3(0.3, 0.3, 0.3);

    void main(void) {
        vec4 texture = textureCube(uSampler, vTextureCoord);
        gl_FragColor = mix(texture, vec4(grey, 1.0), uRainDensity);
        gl_FragColor = mix(gl_FragColor, vec4(sphereColor, 1.0), 0.5);
    }
</script>

<!-- ____________________________________________________________ -->

<script id="vertShadow" type="x-shader/x-vertex">
/**
    Vertex shader used to draw shadow map
*/

    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVPMatrix;        /**< Model view perspective for camera matrix */

    uniform bool uMoveElement;      /**< Apply object movment caused by wind */
    uniform float uTime;            /**< Time passed */
    uniform float uBendFactor;      /**< Max bend of grass caused by wind */
    const float speed = 2.5;        /**< Speed of object wind animation */

    varying vec4 vPosition;         /**< Vertex position in space */
    varying vec2 vTextureCoord;

    void main(void) {
        if (uMoveElement && aTextureCoord.y > 0.75) {
            /**
                Count position of upper vertices after applying wind effect
            */
            float xBend = (sin(uTime * speed) + 0.8) * 0.5 * uBendFactor;
            vPosition = uMVPMatrix * vec4(aVertexPosition.x + xBend, aVertexPosition.y, aVertexPosition.z, 1.0);
            gl_Position = vPosition;  
        } else {
            vPosition = uMVPMatrix * vec4(aVertexPosition, 1.0);
            gl_Position = vPosition;
        }

        /**
            Flip the texture in Y axis
        */
        vTextureCoord = 1.0 - aTextureCoord;
    }
</script>

<script id="fragShadow" type="x-shader/x-fragment">
/**
    Fragment shader used to draw shadow map
*/

    precision mediump float;

    uniform sampler2D uSampler;     /**< Texture applied to the object */

    varying vec4 vPosition;         /**< Vertex position in space */
    varying vec2 vTextureCoord;

    void main(void) {
        /**
            Sample the texture.
            If current pixel is transparent don't draw it.
        */
        vec4 textureColor = texture2D(uSampler, vTextureCoord);
        if (textureColor.a < 0.75) {
            discard;
        }

        /**
            Convert the values from range 0.0 - 200.0 to 0.0 - 1.0
        */
        float distance = vPosition.z * 0.005;
        gl_FragColor = vec4(distance, distance, distance, 1.0);
    }
</script>

<!-- ____________________________________________________________ -->

<script id="vertDof" type="x-shader/x-vertex">
/**
    Vertex shader used to draw DoF texture
*/

    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVPMatrix;        /**< Model view perspective for eye matrix */

    uniform bool uMoveElement;      /**< Apply object movment caused by wind */
    uniform float uTime;            /**< Time passed */
    uniform float uBendFactor;      /**< Max bend of grass caused by wind */
    const float speed = 2.5;        /**< Speed of object wind animation */

    varying vec4 vPosition;         /**< Vertex position in space */
    varying vec2 vTextureCoord;

    void main(void) {
        if (uMoveElement && aTextureCoord.y > 0.75) {
            /**
                Count position of upper vertices after applying wind effect
            */
            float xBend = (sin(uTime * speed) + 0.8) * 0.5 * uBendFactor;
            vPosition = uMVPMatrix * vec4(aVertexPosition.x + xBend, aVertexPosition.y, aVertexPosition.z, 1.0);
            gl_Position = vPosition;
        } else {
            vPosition = uMVPMatrix * vec4(aVertexPosition, 1.0);
            gl_Position = vPosition;
        }

        /**
            Flip the texture in Y axis
        */
        vTextureCoord = 1.0 - aTextureCoord;
    }
</script>

<script id="fragDof" type="x-shader/x-fragment">
/**
    Fragment shader used to draw DoF texture
*/

    precision mediump float;

    uniform sampler2D uSampler;     /**< Texture applied to the object */
    uniform vec3 uDoFSettings;      /**< Near, middle and far plane distance */

    varying vec4 vPosition;         /**< Vertex position in space */
    varying vec2 vTextureCoord;

    void main(void) {
        /**
            Sample the texture.
            If current pixel is transparent don't draw it.
        */
        vec4 textureColor = texture2D(uSampler, vTextureCoord);
        if (textureColor.a < 0.75) {
            discard;
        }

        float blurValue;
        float near = uDoFSettings.x;
        float middle = uDoFSettings.y;
        float far = uDoFSettings.z;

        /**
            Convert the values from range 0.0 - 200.0 to 0.0 - 1.0
        */
        float distance = vPosition.z * 0.005;

        /**
            Count how much blur should be added to the vertex and save it in texture
        */
        if (   distance < near
            || distance > far) {
            blurValue = 1.0;
        }
        if (distance > middle) {
            blurValue = (distance - middle) / (far - middle);
        }
        if (distance < middle) {
            blurValue = (middle - distance) / (middle - near);
        }
        gl_FragColor = vec4(blurValue, blurValue, blurValue, 1.0);
    }
</script>

<!-- ____________________________________________________________ -->

<script id="vertBlur" type="x-shader/x-vertex">
/**
    Vertex shader used to blur texture
*/

    attribute vec3 aVertexPosition;

    varying vec2 vTextureCoord;

    const vec2 v2 = vec2(0.5, 0.5);

    void main(void) {
        vTextureCoord = aVertexPosition.xy * v2 + v2;
        gl_Position = vec4(aVertexPosition.xy, 0.0, 1.0);
    }
</script>

<script id="fragHorizontalBlurDOF" type="x-shader/x-fragment">
/**
    Fragment shader used to gauss blur texture horizontally
*/

    precision mediump float;

    uniform sampler2D uSampler;         /**< Texture rendered with previous pass */
    uniform sampler2D uDepthSampler;    /**< Depth of Field texture sampler */

    varying vec2 vTextureCoord;

    const float offset = 1.0 / 768.0;   /**< How much to move to take next texture sample */

    void main(void) {
        /**
            Count offset to take next DoF texture sample
        */
        float zValue = texture2D(uDepthSampler, vTextureCoord).r;
        float blurSize = offset * zValue;

        /**
            Add horizontal gaussian blur
        */
        const float gb1 = 0.38774;
        const float gb2 = 0.24477;
        const float gb3 = 0.06136;
        vec4 sample = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)) * gb1;
        sample     += texture2D(uSampler, vec2(vTextureCoord.s + blurSize, vTextureCoord.t)) * gb2;
        sample     += texture2D(uSampler, vec2(vTextureCoord.s - blurSize, vTextureCoord.t)) * gb2;
        sample     += texture2D(uSampler, vec2(vTextureCoord.s + blurSize * 2.0, vTextureCoord.t)) * gb3;
        sample     += texture2D(uSampler, vec2(vTextureCoord.s - blurSize * 2.0, vTextureCoord.t)) * gb3;
        gl_FragColor = sample;
    }
</script>


<script id="fragVerticalBlurDOF" type="x-shader/x-fragment">
/**
    Fragment shader used to gauss blur texture vertically
*/

    precision mediump float;

    uniform sampler2D uSampler;         /**< Texture rendered with previous pass */
    uniform sampler2D uDepthSampler;    /**< Depth of Field texture sampler */

    varying vec2 vTextureCoord;

    const float offset = 1.0 / 768.0;   /**< How much to move to take next texture sample */

    void main(void) {
        /**
            Count offset to take next DoF texture sample
        */
        float zValue = texture2D(uDepthSampler, vTextureCoord).r;
        float blurSize = offset * zValue;

        /**
            Add vertical gaussian blur
        */
        const float gb1 = 0.38774;
        const float gb2 = 0.24477;
        const float gb3 = 0.06136;
        vec4 sample = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t)) * gb1;
        sample +=  texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t + blurSize)) * gb2;
        sample +=  texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t - blurSize)) * gb2;
        sample +=  texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t + blurSize * 2.0)) * gb3;
        sample +=  texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t - blurSize * 2.0)) * gb3;
        gl_FragColor = sample;
    }
</script>

<script id="fragMotionBlur" type="x-shader/x-fragment">
/**
    Fragment shader used to add motion blur
*/

    precision mediump float;

    uniform sampler2D uSampler;
    uniform sampler2D uCopyTextureSamplerA;
    uniform sampler2D uCopyTextureSamplerB;
    uniform sampler2D uCopyTextureSamplerC;
    uniform sampler2D uCopyTextureSamplerD;
    uniform sampler2D uCopyTextureSamplerE;

    varying vec2 vTextureCoord;

    void main(void) {
        vec4 copiedTextureA = texture2D(uCopyTextureSamplerA, vTextureCoord);
        vec4 copiedTextureB = texture2D(uCopyTextureSamplerB, vTextureCoord);
        vec4 copiedTextureC = texture2D(uCopyTextureSamplerC, vTextureCoord);
        vec4 copiedTextureD = texture2D(uCopyTextureSamplerD, vTextureCoord);
        vec4 copiedTextureE = texture2D(uCopyTextureSamplerE, vTextureCoord);

        /**
            Mix current scene with previous ones
        */
        gl_FragColor = texture2D(uSampler, vTextureCoord);
        gl_FragColor = mix(gl_FragColor, copiedTextureA, 0.4);
        gl_FragColor = mix(gl_FragColor, copiedTextureB, 0.45);
        gl_FragColor = mix(gl_FragColor, copiedTextureC, 0.5);
        gl_FragColor = mix(gl_FragColor, copiedTextureD, 0.55);
        gl_FragColor = mix(gl_FragColor, copiedTextureE, 0.6);
    }
</script>

<script id="fragRadialBlur" type="x-shader/x-fragment">
/**
    Fragment shader used to add radial blur
*/

    precision mediump float;

    uniform sampler2D uSampler;             /**< Texture rendered with previous pass */
    uniform float uSpeed;                   /**< Camera movement speed */

    varying vec2 vTextureCoord;

    const float sampleStrength = 2.2;       /**< How much impact on result should have the taken samples */
    const float sumDivider = 1.0 / 11.0;    /**< Divide 11 taken samples by 11 to get the correct color */
    const float offset = 1.0 / 768.0;       /**< How much to move to take next texture sample */

    void main(void) {
        if (uSpeed > 0.1) {
            vec4 color = texture2D(uSampler, vTextureCoord);

            /**
                Count direction in which you need to move to take next samples
            */
            vec2 blurCenter = vec2(0.5, 0.5);
            vec2 direction = blurCenter - vTextureCoord;
            float distance = sqrt(direction.x * direction.x + direction.y * direction.y);
            direction = direction / distance;
            vec4 sum = color;

            /**
                Take texture samples
            */
            for (float i = 1.0; i < 10.1; i++) {
                sum += texture2D(uSampler, vTextureCoord + direction * (offset * i) * uSpeed);
            }
            sum *= sumDivider;

            /**
                Count blured samples visibility
            */
            float ratio = distance * sampleStrength;
            ratio = clamp(ratio, 0.0, 1.0);

            /**
                Mix base color with blured samples
            */
            gl_FragColor = mix(color, sum, ratio);
        } else {
            gl_FragColor = texture2D(uSampler, vTextureCoord);
        }
    }
</script>

<!-- ____________________________________________________________ -->

<script id="vertScreen" type="x-shader/x-vertex">
/**
    Vertex shader used to draw texture on screen
*/

    attribute vec3 aVertexPosition;

    varying vec2 vTextureCoord;

    const vec2 v2 = vec2(0.5, 0.5);

    void main(void) {
        vTextureCoord = aVertexPosition.xy * v2 + v2;
        gl_Position = vec4(aVertexPosition.xy, 0.0, 1.0);
    }
</script>

<script id="fragScreen" type="x-shader/x-fragment">
/**
    Fragment shader used to draw texture on screen
*/

    precision mediump float;

    uniform sampler2D uSampler;             /**< Texture to be drawn on screen */

    varying vec2 vTextureCoord;

    void main(void) {
        gl_FragColor = texture2D(uSampler, vTextureCoord);
    }
</script>

<!-- ____________________________________________________________ -->

<script type="text/javascript">
    var gl;
    var g_FPS = 0;

    function redraw() {
        countSceneCameraMatrix();
        if (depthOfField) {
            /**
                Draw scene to store blur level information
            */
            drawDOF();
        }
        if (shadows) {
            /**
                Draw scene to store Z values
            */
            drawShadows();
        }
        /**
            Draw scene to offscreen texture
        */
        drawScene();
        /**
            Add postprocessing effects and draw scene on screen
        */
        drawOnScreen();
    }

    /**
        Wind animation variables
    */
    var windTextureMove = 0.0;
    var totalTime = 0.0;

    /**
        Test run animation variables
    */
    var direction = 1;
    var changeCamRotateHorizontal = false;
    var targetCamRotateHorizontal = 0;
    var changeCamRotateVertical = false;
    var targetCamRotateVertical = 0;
    var changeSpeed = false;
    var targetSpeed = 0;
    var changeCamHeight = false;
    var targetCamHeight = 0;
    var yLevel;

    function animate() {
        /**
            Increase time variables
        */
        windTextureMove += 0.003;
        if (windTextureMove > 1.0) {
            windTextureMove = 0.0;
        }
        totalTime += 0.01;

        /**
            Changes behaviour of the eye camera depending on moveMode variable
        */
        switch(moveMode) {
            case 1:
                camXPos += speed * Math.sin(degToRad(camRotateHorizontal));
                camZPos -= speed * Math.cos(degToRad(camRotateHorizontal));
                camYPos = getPixelAvg(terrainData, camXPos, -camZPos) / 255.0 * terrainHeight + camHeight;
                break;
            case 2:
                camXPos += speed * Math.sin(degToRad(camRotateHorizontal));
                camZPos -= speed * Math.cos(degToRad(camRotateHorizontal));
                camYPos = yLevel + camHeight;
                break;
            case 3:
                camXPos += speed * Math.sin(degToRad(camRotateHorizontal));
                camZPos -= speed * Math.cos(degToRad(camRotateHorizontal));
                camYPos -= speed * Math.sin(degToRad(camRotateVertical));
                break;
            default:
                break;
        }

        /**
            Starts the next stages of test run
        */
        if (camZPos < -58.0 && direction == 2) {
            test();
        }
        if (camXPos > 90.0  && direction == 3) {
            test();
        }
        if (camZPos > -50.0 && direction == 4) {
            test();
        }
        if (camXPos < 44.0  && direction == 5) {
            test();
        }
        if (camZPos < -70.0 && direction == 6) {
            test();
        }
        if (camXPos > 100.0 && direction == 7) {
            test();
        }
        if (camZPos > -16.0 && direction == 8) {
            test();
        }
        if (camZPos < -64.0 && direction == 9) {
            test();
        }
        if (camZPos < -90.0 && direction == 10) {
            test();
        }
        if (camXPos < 5.0   && direction == 11) {
            test();
        }

        /**
            Applies changes to the camera angles, speed and height
        */
        if (changeCamRotateHorizontal) {
            if (camRotateHorizontal < targetCamRotateHorizontal) {
                camRotateHorizontal += 2.0;
                if (camRotateHorizontal >= targetCamRotateHorizontal) {
                    changeCamRotateHorizontal = false;
                }
            } else {
                camRotateHorizontal -= 2.0;
                if (camRotateHorizontal <= targetCamRotateHorizontal) {
                    changeCamRotateHorizontal = false;
                }
            }
        }

        if (changeCamRotateVertical) {
            if (camRotateVertical < targetCamRotateVertical) {
                camRotateVertical += 1.0;
                if (camRotateVertical >= targetCamRotateVertical) {
                    changeCamRotateVertical = false;
                }
            } else {
                camRotateVertical -= 1.0;
                if (camRotateVertical <= targetCamRotateVertical) {
                    changeCamRotateVertical = false;
                }
            }
        }

        if (changeSpeed) {
            if (speed < targetSpeed) {
                speed += 0.03;
                if (speed >= targetSpeed) {
                    changeSpeed = false;
                }
            } else {
                speed -= 0.03;
                if (speed <= targetSpeed) {
                    changeSpeed = false;
                }
            }
        }

        if (changeCamHeight) {
            if (camHeight < targetCamHeight) {
                camHeight += 0.1;
                if (camHeight >= targetCamHeight) {
                    changeCamHeight = false;
                }
            } else {
                camHeight -= 0.1;
                if (camHeight <= targetCamHeight) {
                    changeCamHeight = false;
                }
            }
        }
    }

    /**
        FPS counter variables
    */
    var numberOfFrames = 0;
    var startTime = 0;
    var endTime = 0;

    function test() {
        /**
            Sets variables for the next stages of test run
        */
        switch(direction) {
            case 1:
                moveMode = 1;
                direction = 2;
                totalTime = 0.0;
                camRotateHorizontal = 10.0;
                camRotateVertical = 0.0;
                camXPos = 1.0;
                camYPos = getPixel(terrainData, camXPos, -camZPos).a / 255.0 * terrainHeight + camHeight;
                camZPos = -1.0;
                speed = 1.0;
                camHeight = 1.5;
                resetRain();
                break;

            case 2:
                startTime = new Date().getTime();
                numberOfFrames = 0;

                direction = 3;
                targetCamRotateHorizontal = 120.0;
                changeCamRotateHorizontal = true;
                targetCamRotateVertical = -5.0;
                changeCamRotateVertical = true;
                targetSpeed = 2.0;
                changeSpeed = true;
                targetCamHeight = 3.0;
                changeCamHeight = true;
                break;

            case 3:
                direction = 4;
                targetCamRotateHorizontal = 180.0;
                changeCamRotateHorizontal = true;
                targetCamRotateVertical = 10.0;
                changeCamRotateVertical = true;
                targetSpeed = 1.0;
                changeSpeed = true;
                targetCamHeight = 1.5;
                changeCamHeight = true;
                break;

            case 4:
                direction = 5;
                targetCamRotateHorizontal = 270.0;
                changeCamRotateHorizontal = true;
                targetCamRotateVertical = 25.0;
                changeCamRotateVertical = true;
                targetSpeed = 1.25;
                changeSpeed = true;
                targetCamHeight = 2.0;
                changeCamHeight = true;
                break;

            case 5:
                direction = 6;
                moveMode = 2;
                camRotateHorizontal = -90.0;
                targetCamRotateHorizontal = 20.0;
                changeCamRotateHorizontal = true;
                targetCamRotateVertical = 30.0;
                changeCamRotateVertical = true;
                targetSpeed = 0.5;
                changeSpeed = true;
                camHeight = 0.0;
                yLevel = camYPos;
                targetCamHeight = 5.0;
                changeCamHeight = true;
                break;

            case 6:
                direction = 7;
                targetCamRotateHorizontal = 100.0;
                changeCamRotateHorizontal = true;
                targetCamRotateVertical = 20.0;
                changeCamRotateVertical = true;
                targetSpeed = 0.7;
                changeSpeed = true;
                targetCamHeight = 5.5;
                changeCamHeight = true;
                break;

            case 7:
                direction = 8;
                targetCamRotateHorizontal = 230.0;
                changeCamRotateHorizontal = true;
                targetCamRotateVertical = 30.0;
                changeCamRotateVertical = true;
                targetSpeed = 0.6;
                changeSpeed = true;
                targetCamHeight = 8.0;
                changeCamHeight = true;
                break;

            case 8:
                direction = 9;
                camRotateHorizontal = -130.0;
                targetCamRotateHorizontal = 0.0;
                changeCamRotateHorizontal = true;
                targetCamRotateVertical = 30.0;
                changeCamRotateVertical = true;
                targetSpeed = 0.6;
                changeSpeed = true;
                camHeight = 0.0;
                yLevel = camYPos;
                targetCamHeight = 9.0;
                changeCamHeight = true;
                break;

            case 9:
                direction = 10;
                targetCamRotateHorizontal = 370.0;
                changeCamRotateHorizontal = true;
                targetCamRotateVertical = 55.0;
                changeCamRotateVertical = true;
                targetSpeed = 0.6;
                changeSpeed = true;
                targetCamHeight = 15.0;
                changeCamHeight = true;
                break;

            case 10:
                direction = 11;
                camRotateHorizontal = 10.0;
                targetCamRotateHorizontal = 260.0;
                changeCamRotateHorizontal = true;
                targetCamRotateVertical = 60.0;
                changeCamRotateVertical = true;
                targetSpeed = 1.2;
                changeSpeed = true;
                targetCamHeight = 20.0;
                changeCamHeight = true;
                break;

            case 11:
                endTime = new Date().getTime();
                showStats();

                direction = 1;
                moveMode = 4;
                speed = 0.0;
                changeCamRotateHorizontal = false;
                changeCamRotateVertical = false;
                changeSpeed = false;
                changeCamHeight = false;
                break;

            default:
                break;
        }
    }

    /**
        Displays alert with statistics at the end of test run
    */
    function showStats() {
        var n = "\n";
        var t = "  ";
        var sec = (endTime - startTime) / 1000.0;
        alert("Done!"
                +n+ "Framerate:"
                +n+t+ "Number of frames: " + numberOfFrames
                +n+t+ "Time: " + sec.toFixed(2) + "s"
                +n+t+ "Average: " + (numberOfFrames / sec).toFixed(2)
                +n+n+ "Settings:"
                +n+t+ "Batch grass: "        + batchGrass
                +n+t+ "Grass density: "      + grassDensity
                +n+t+ "Batch red flowers: "        + batchFlower[0]
                +n+t+ "Red flowers density: "      + flowerDensity[0]
                +n+t+ "Batch blue flowers: "        + batchFlower[1]
                +n+t+ "Blue flowers density: "      + flowerDensity[1]
                +n+t+ "Number of trees: "      + numberOfTrees
				+n+t+ "Wind: "                 + wind
                +n+t+ "Rain: "                 + rain
                +n+t+t+ "Rain density: "     + rainDensity
                +n+t+ "Render skybox: "      + skybox
                +n+t+ "Use radial blur: "    + radialBlur
                +n+t+ "Use depth of field: " + depthOfField
                +n+t+t+ "Depth of field settings:"
                +n+t+t+t+ "Near: "   + dofSettings[0]
                +n+t+t+t+ "Middle: " + dofSettings[1]
                +n+t+t+t+ "Far: "    + dofSettings[2]
                +n+t+ "Use shadows: " + shadows
                +n+t+t+ "Use soft shadows: " + softShadows
                +n+t+ "Use lighting: " + lighting
                +n+t+t+ "Light settings:"
                +n+t+t+t+ "Point light position:"
                +n+t+t+t+t+ "X: " + lightLocation[0]
                +n+t+t+t+t+ "Y: " + lightLocation[1]
                +n+t+t+t+t+ "Z: " + lightLocation[2]
                +n+t+t+t+ "Point light color:"
                +n+t+t+t+t+ "R: " + pointLightColor[0]
                +n+t+t+t+t+ "G: " + pointLightColor[1]
                +n+t+t+t+t+ "B: " + pointLightColor[2]
                +n+t+t+t+ "Ambient light color:"
                +n+t+t+t+t+ "R: " + ambientColor[0]
                +n+t+t+t+t+ "G: " + ambientColor[1]
                +n+t+t+t+t+ "B: " + ambientColor[2]
        );
    }

    /**
        Checks if buffers are filled and ready to draw
    */
    function checkBuffers() {
        if (   !treeVertexPositionBuffer
            || !treeIndicesBuffer) {
            return false;
        }
        if (   !terrainVertexPositionBuffer
            || !terrainTextureCoordsBuffer
            || !terrainIndicesBuffer) {
            return false;
        }
        return true;
    }

    /**
        Main drawing loop
    */
    var loaded = false;
    function tick() {
        if (!loaded) {
            loaded = checkBuffers();
        } else {
            handleKeys();
            animate();
            redraw();

            g_FPS.snapshot();
            numberOfFrames++;
        }
        requestAnimFrame(tick);
    }

    var screenWidth;
    var screenHeight;
    function webGLStart() {
        /**
            Get canvas to draw with GL
        */
        var canvas          = document.getElementById("can");
        screenWidth         = window.innerWidth;
        screenHeight        = window.innerHeight;
        canvas.style.width  = screenWidth + "px";
        canvas.style.height = screenHeight + "px";

        /**
            Initialize GL context and it's components
        */
        gl = initGL(canvas);
        initFramebuffers();
        initShaders();
        initBuffers();
        initTextures();
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);

        setInputValues();

        /**
            Show FPS stats in proper divs
        */
        g_FPS = new Framerate('frameRate');

        /**
            Get input mouse and keyboard events
        */
        canvas.onmousedown   = handleMouseDown;
        document.onmouseup   = handleMouseUp;
        document.onmousemove = handleMouseMove;
        document.onkeydown   = handleKeyDown;
        document.onkeyup     = handleKeyUp;

        /**
            Start main rendering loop
        */
        tick();
    }
</script>
</head>

<body onload="webGLStart();">
    <canvas id="can" style="border: none;" width="1024" height="1024"></canvas>

    <input id="startTest" type="button" value="Start test" onclick=test()></input><br />

    <div id="frameRate"></div>
    <div id="frameTime"></div>

    <input type="checkbox" id="batchGrass" onchange="cbBatchGrass(this)" checked /> Batch grass<br />
    Grass density: <input id="grassDensity" type="range" min=1.0 max=10.0 step=0.1 value=1.0 onchange="moveGrassSlider(this)" />
    <br />

    <br />
    <input type="checkbox" id="batchFlowerRed" onchange="cbBatchFlowerRed(this)" checked /> Batch red flowers 
    <input type="checkbox" id="batchFlowerBlue" onchange="cbBatchFlowerBlue(this)" checked /> Batch blue flowers<br />
    Red flower density: <input id="flowerRedDensity" type="range" min=1.0 max=10.0 step=0.1 value=4.7 onchange="moveFlowerRedSlider(this)" />
    <br />
    Blue flower density: <input id="flowerBlueDensity" type="range" min=1.0 max=10.0 step=0.1 value=5.3 onchange="moveFlowerBlueSlider(this)" />
    <br />

    <br />
    Number of trees: <input type="number" id="numberOfTrees" min=0 max=6 value=6 onchange="numTrees(this)" /><br />

    <br />
    <input type="checkbox" id="wind" onchange="cbWind(this)" checked /> Wind<br />
	
    <br />
    <input type="checkbox" id="rain" onchange="cbRain(this)" checked /> Rain<br />
    Rain density: <input id="rainDensity" type="range" min=1 max=250000 step=1 value=10000 onchange="moveRainSlider(this)" />
    <br />

    <br />
    <input type="checkbox" id="skybox" onchange="cbSkybox(this)" checked /> Render Skybox<br />

    <br />
    <input type="checkbox" id="radialBlur" onchange="cbRadialBlur(this)" checked /> Use Radial Blur<br />

    <br />
    <input type="checkbox" id="motionBlur" onchange="cbMotionBlur(this)" checked /> Use Motion Blur<br />

    <br />
    <input type="checkbox" id="depthOfField" onchange="cbDepthOfField(this)" checked /> Use Depth of Field<br />

    <h2>Depth of Field:</h2>
    <table style="border: 0; padding: 10px;">
        <tr>
            <td>Near: <input type="text" id="near" value="0.1" onchange="tbDOFN(this)" />
            <td>Middle: <input type="text" id="middle" value="0.3" onchange="tbDOFM(this)" />
            <td>Far: <input type="text" id="far" value="0.5" onchange="tbDOFF(this)" />
        </tr>
    </table>

    <br />
    <input type="checkbox" id="shadows" onchange="cbShadows(this)" checked /> Use shadows
        <input type="checkbox" id="softShadows" onchange="cbSoftShadows(this)" checked /> Use soft shadows<br />
    <br />
    <input type="checkbox" id="lighting" onchange="cbLighting(this)" checked /> Use lighting<br />

    <h2>Point light:</h2>
    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Location:</b>
            <td>X: <input type="text" id="lightLocationX" value="10.0" onchange="tbLightLocationX(this)" />
            <td>Y: <input type="text" id="lightLocationY" value="30.0" onchange="tbLightLocationY(this)" />
            <td>Z: <input type="text" id="lightLocationZ" value="20.0" onchange="tbLightLocationZ(this)" />
        </tr>
        <tr>
            <td><b>Color:</b>
            <td>R: <input type="text" id="lightR" value="0.8" onchange="tbLightR(this)" />
            <td>G: <input type="text" id="lightG" value="0.8" onchange="tbLightG(this)" />
            <td>B: <input type="text" id="lightB" value="0.8" onchange="tbLightB(this)" />
        </tr>
    </table>

    <h2>Ambient light:</h2>
    <table style="border: 0; padding: 10px;">
        <tr>
            <td><b>Color:</b>
            <td>R: <input type="text" id="ambientR" value="0.4" onchange="tbAmbientR(this)" />
            <td>G: <input type="text" id="ambientG" value="0.4" onchange="tbAmbientG(this)" />
            <td>B: <input type="text" id="ambientB" value="0.4" onchange="tbAmbientB(this)" />
        </tr>
    </table>
</body>

</html>
